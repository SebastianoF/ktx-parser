< header
100 numpy exercises - some more sample file


< sub_header
part 2: here we have another sample from numpy 100, to test ktx parser

This file is automatically generated from a source file via ktx_parser.

And we can not conclude the sub-header without another message: all the examples are from https://github.com/rougier/numpy-100


< interactive_initialisation
# Instantiate a getter into the session
# and call hints and answers via its attributes:
# E.g. get.hint(3) or get.answer(3) or get.random_question()

import os
from ktx_parser.getter_question_hint_answer import GetterQuestionHintAnswer

get = GetterQuestionHintAnswer('../source/part2.ktx').get_entries()


< q96
Given a two dimensional array, how to extract unique rows? (★★★)

< h96
hint: np.ascontiguousarray | np.unique

< a96
# Author: Jaime Fernández del Río

Z = np.random.randint(0,2,(6,3))
T = np.ascontiguousarray(Z).view(np.dtype((np.void, Z.dtype.itemsize * Z.shape[1])))
_, idx = np.unique(T, return_index=True)
uZ = Z[idx]
print(uZ)

# Author: Andreas Kouzelis
# NumPy >= 1.13
uZ = np.unique(Z, axis=0)
print(uZ)

< q97
Considering 2 vectors A & B, write the einsum equivalent of inner, outer, sum, and mul function (★★★)

< h97
hint: np.einsum

< a97
# Author: Alex Riley
# Make sure to read: http://ajcr.net/Basic-guide-to-einsum/

A = np.random.uniform(0,1,10)
B = np.random.uniform(0,1,10)

np.einsum('i->', A)       # np.sum(A)
np.einsum('i,i->i', A, B) # A * B
np.einsum('i,i', A, B)    # np.inner(A, B)
np.einsum('i,j->ij', A, B)    # np.outer(A, B)

< q98
Considering a path described by two vectors (X,Y), how to sample it using equidistant samples (★★★)?

< h98
hint: np.cumsum, np.interp

< a98
# Author: Bas Swinckels

phi = np.arange(0, 10*np.pi, 0.1)
a = 1
x = a*phi*np.cos(phi)
y = a*phi*np.sin(phi)

dr = (np.diff(x)**2 + np.diff(y)**2)**.5 # segment lengths
r = np.zeros_like(x)
r[1:] = np.cumsum(dr)                # integrate path
r_int = np.linspace(0, r.max(), 200) # regular spaced path
x_int = np.interp(r_int, r, x)       # integrate path
y_int = np.interp(r_int, r, y)

< q99
Given an integer n and a 2D array X, select from X the rows which can be interpreted as draws from a multinomial distribution with n degrees, i.e., the rows which only contain integers and which sum to n. (★★★)

< h99
hint: np.logical_and.reduce, np.mod

< a99
# Author: Evgeni Burovski

X = np.asarray([[1.0, 0.0, 3.0, 8.0],
                [2.0, 0.0, 1.0, 1.0],
                [1.5, 2.5, 1.0, 0.0]])
n = 4
M = np.logical_and.reduce(np.mod(X, 1) == 0, axis=-1)
M &= (X.sum(axis=-1) == n)
print(X[M])

< q100
Compute bootstrapped 95% confidence intervals for the mean of a 1D array X (i.e., resample the elements of an array with replacement N times, compute the mean of each sample, and then compute percentiles over the means). (★★★)

< h100
hint: np.percentile

< a100
# Author: Jessica B. Hamrick

X = np.random.randn(100) # random 1D array
N = 1000 # number of bootstrap samples
idx = np.random.randint(0, X.size, (N, X.size))
means = X[idx].mean(axis=1)
confint = np.percentile(means, [2.5, 97.5])
print(confint)